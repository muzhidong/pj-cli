diff --git a/node_modules/cli-table3/src/cell.js b/node_modules/cli-table3/src/cell.js
index 8c3df35..9f4aa8b 100644
--- a/node_modules/cli-table3/src/cell.js
+++ b/node_modules/cli-table3/src/cell.js
@@ -116,7 +116,8 @@ class Cell {
     this.width = this.widths.reduce(sumPlusOne, -1);
     this.height = this.heights.reduce(sumPlusOne, -1);
 
-    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];
+    const { rowIndex, headHAlign = ''} = tableOptions;
+    this.hAlign = this.options.hAlign || tableOptions.colAligns[x] || rowIndex === 0 && headHAlign;
     this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];
 
     this.drawRight = x + this.colSpan == tableOptions.colWidths.length;
diff --git a/node_modules/cli-table3/src/table.js b/node_modules/cli-table3/src/table.js
index eb4a9bd..15aef32 100644
--- a/node_modules/cli-table3/src/table.js
+++ b/node_modules/cli-table3/src/table.js
@@ -58,9 +58,9 @@ class Table extends Array {
     tableLayout.computeWidths(this.options.colWidths, cells);
     tableLayout.computeHeights(this.options.rowHeights, cells);
 
-    cells.forEach(function (row) {
+    cells.forEach(function (row, rowIndex) {
       row.forEach(function (cell) {
-        cell.init(this.options);
+        cell.init({...this.options, rowIndex});
       }, this);
     }, this);
 
diff --git a/node_modules/cli-table3/src/utils.js b/node_modules/cli-table3/src/utils.js
index c922c5b..90e51e3 100644
--- a/node_modules/cli-table3/src/utils.js
+++ b/node_modules/cli-table3/src/utils.js
@@ -240,33 +240,49 @@ function mergeOptions(options, defaults) {
   return ret;
 }
 
+function splitBySeparator(separator, target){
+  const dict = {
+    comma: {reg: /，/g, char: '，'},
+    stopSignal: {reg: /、/g, char: '、'},
+  }
+  const targetArr = [...target];
+  let cursor = 0;
+  target.forEach(item => {
+    let arr = item.split(dict[separator].reg);
+    arr = arr.map((val, i)=>{
+      if(i === 0) return val;
+      return `${dict[separator].char}${val}`;
+    });
+    targetArr.splice(cursor, 1, ...arr)
+    cursor += arr.length;
+  })
+  return targetArr;
+}
+
 // Wrap on word boundary
 function wordWrap(maxLength, input) {
   let lines = [];
   let split = input.split(/(\s+)/g);
+  split = splitBySeparator('comma', split);
+  split = splitBySeparator('stopSignal', split);
   let line = [];
   let lineLength = 0;
-  let whitespace;
-  for (let i = 0; i < split.length; i += 2) {
+  for (let i = 0; i < split.length; i += 1) {
     let word = split[i];
     let newLength = lineLength + strlen(word);
-    if (lineLength > 0 && whitespace) {
-      newLength += whitespace.length;
-    }
     if (newLength > maxLength) {
       if (lineLength !== 0) {
-        lines.push(line.join(''));
+        lines.push(line.join('').trim());
       }
       line = [word];
       lineLength = strlen(word);
     } else {
-      line.push(whitespace || '', word);
+      line.push(word);
       lineLength = newLength;
     }
-    whitespace = split[i + 1];
-  }
-  if (lineLength) {
-    lines.push(line.join(''));
+    if (i === split.length - 1) {
+      lines.push(line.join('').trim());
+    }
   }
   return lines;
 }
